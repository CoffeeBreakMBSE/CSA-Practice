<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSA Practice</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; max-width: 980px; margin: 24px auto; padding: 0 16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 12px 0; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    button { padding: 10px 14px; border: 1px solid #ccc; background: #fafafa; border-radius: 10px; cursor: pointer; }
    button.primary { background: #1f6feb; color: white; border-color: #1f6feb; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .pill { font-size: 12px; padding: 4px 10px; border-radius: 999px; background: #f2f2f2; }
    .opt { display: block; padding: 10px 12px; border: 1px solid #ddd; border-radius: 10px; margin: 8px 0; cursor: pointer; }
    .opt input { margin-right: 8px; }
    .good { color: #1a7f37; }
    .bad { color: #cf222e; }
    .muted { color: #666; }
    select, input[type="file"], input[type="number"] { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; }
    .hint { font-size: 12px; color: #666; margin-top: 8px; line-height: 1.35; }
    code { background: #f6f8fa; padding: 2px 6px; border-radius: 6px; }

    .tabs { display: flex; gap: 8px; margin: 10px 0 0; }
    .tab {
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 10px;
      background: #fafafa;
      cursor: pointer;
      user-select: none;
    }
    .tab.active {
      background: #1f6feb;
      color: white;
      border-color: #1f6feb;
    }

    .review-item {
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 12px;
      margin: 10px 0;
      background: #fff;
    }
    .review-item .qtitle { font-weight: 700; margin-bottom: 6px; }
    .review-item .meta { font-size: 12px; color: #666; margin-bottom: 6px; }
    .review-item .ans { font-size: 14px; margin-top: 6px; }
    .review-item .ans span { display: inline-block; margin-right: 10px; }

    button.warn { border-color: #f59e0b; background: #fff7ed; }
    .pill.warn { background: #fff7ed; border: 1px solid #f59e0b; }
  </style>
</head>

<body>
  <h1>ServiceNow CSA Practice</h1>

  <div class="card">
    <div class="row" style="justify-content: space-between;">
      <div class="row">
        <span class="pill" id="stats">0/0</span>
        <span class="pill" id="score">Score: 0</span>
      </div>

      <div class="row" style="gap:10px;">
        <label class="muted">Question set:
          <select id="csvSelect">
            <option value="File1.csv">File1.csv</option>
            <option value="File2_pdf.csv">File2_pdf.csv</option>
          </select>
        </label>

        <label class="muted">Or load file:
          <input type="file" id="fileInput" accept=".csv" />
        </label>

        <span class="pill" id="loadStatus">Ready</span>
        <span class="pill" id="reviewCountPill">Review: 0</span>
      </div>
    </div>

    <div class="tabs">
      <div class="tab active" id="tabPractice">Practice</div>
      <div class="tab" id="tabTest">Test (Mock Exam)</div>
    </div>

    <div id="practiceControls">
      <div class="row" style="margin-top: 12px;">
        <label class="muted">Module:
          <select id="moduleFilter">
            <option value="ALL">All</option>
          </select>
        </label>

        <label class="muted">Filter:
          <select id="reviewFilter">
            <option value="ALL">All questions</option>
            <option value="REVIEW">Marked for review</option>
          </select>
        </label>

        <button id="btnPrev">Prev</button>
        <button class="primary" id="btnNext">Next</button>
        <button id="btnShuffle">Shuffle</button>
        <button id="btnReset">Reset</button>
      </div>
    </div>

    <div id="testControls" style="display:none;">
      <div class="row" style="margin-top: 12px;">
        <span class="pill" id="testStatus">Not started</span>

        <label class="muted">Questions:
          <input type="number" id="testCount" min="10" max="200" value="60" style="width: 90px;" />
        </label>

        <button class="primary" id="btnStartTest">Start Test</button>
        <button id="btnEndTest" disabled>End Test</button>
        <button id="btnSubmitTest" disabled>Submit</button>
        <button id="btnResetTest" disabled>Reset Test</button>
      </div>

      <div class="hint">
        <strong>Test mode:</strong> random set of questions, no instant feedback. Submit to see score + review.
      </div>
    </div>

    <div class="hint">
      <strong>CSV format required:</strong>
      <code>id,module,question,A,B,C,D,answer,explanation</code>.
      <br/>
      <strong>Multi-select:</strong> set <code>answer</code> to multiple letters like <code>AC</code> or <code>BDE</code>.
    </div>

    <div class="hint">
      <strong>Review persistence:</strong> marked questions are saved in <code>localStorage</code> per question set.
    </div>
  </div>

  <div class="card" id="questionCard">
    <div class="row" style="justify-content: space-between;">
      <div><div class="pill" id="modulePill">Module</div></div>
      <div class="muted" id="qIndex">Question</div>
    </div>

    <h2 id="questionText" style="margin: 12px 0 8px;"></h2>
    <div class="muted" id="chooseHint" style="margin-bottom: 6px;"></div>
    <div id="options"></div>

    <div class="row" style="margin-top: 10px;">
      <button id="btnToggleReview">☆ Mark for review</button>
      <button id="btnClearReview" title="Clears all marked questions for the current question set">Clear review list</button>
    </div>

    <div id="feedback" style="margin-top: 12px;"></div>
  </div>

  <div class="card" id="testResults" style="display:none;">
    <div class="row" style="justify-content: space-between;">
      <div>
        <div style="font-size: 18px; font-weight: 800;">Mock Exam Results</div>
        <div class="muted" id="resultsSummary" style="margin-top: 4px;"></div>
      </div>
      <div class="row">
        <button id="btnShowAllReview">Show Review</button>
        <button id="btnHideReview" style="display:none;">Hide Review</button>
      </div>
    </div>

    <div id="reviewContainer" style="display:none; margin-top: 12px;"></div>
  </div>

  <script>
    // -------------------------
    // Review persistence (localStorage)
    // -------------------------
    // We store review IDs per "question set key" so File1/File2 have separate lists.
    // For uploads, we use a content hash (fast non-crypto) to keep it stable for same file content.
    const LS_PREFIX = "csa_review_ids_v1:";
    const LS_LAST_SET_KEY = "csa_last_set_key_v1";

    let currentSetKey = "builtin"; // updated after loading a set

    function fastHash(str) {
      // Simple FNV-1a-ish hash (fast, good enough for stable keys)
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0).toString(16);
    }

    function getStorageKeyForSet(setKey) {
      return LS_PREFIX + setKey;
    }

    function saveReviewToStorage() {
      try {
        const arr = Array.from(reviewMarked);
        localStorage.setItem(getStorageKeyForSet(currentSetKey), JSON.stringify(arr));
        localStorage.setItem(LS_LAST_SET_KEY, currentSetKey);
      } catch (e) {
        console.warn("Failed to save review list:", e);
      }
    }

    function loadReviewFromStorage(setKey) {
      reviewMarked.clear();
      try {
        const raw = localStorage.getItem(getStorageKeyForSet(setKey));
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          for (const id of arr) {
            if (typeof id === "string") reviewMarked.add(id);
          }
        }
      } catch (e) {
        console.warn("Failed to load review list:", e);
      }
    }

    function clearReviewStorageForCurrentSet() {
      try {
        localStorage.removeItem(getStorageKeyForSet(currentSetKey));
      } catch {}
    }

    // -------------------------
    // Default fallback questions
    // -------------------------
    let QUESTIONS = [
      {
        id: "M6-QX01",
        module: "Module 6: Reports & Notifications",
        text: "Reports can be created from which places? (Choose two)",
        options: ["List column heading", "Metrics module", "Statistics module", "View / Run module"],
        correctSet: new Set([0, 3]),
        explanation: "Reports can be created from list headers and from View/Run."
      },
      {
        id: "M8-Q01",
        module: "Module 8: Update Sets",
        text: "What is the correct order when importing an update set?",
        options: ["Commit → Preview → Retrieve", "Retrieve → Commit → Preview", "Retrieve → Preview → Commit", "Preview → Retrieve → Commit"],
        correctSet: new Set([2]),
        explanation: "You retrieve/import, preview to identify issues, then commit to apply changes."
      }
    ];

    const MODE = { PRACTICE: "practice", TEST: "test" };
    let currentMode = MODE.PRACTICE;

    // PRACTICE
    let practiceFiltered = [];
    let practiceIdx = 0;
    let practiceScore = 0;
    const practiceAnswers = new Map();

    // TEST
    let testQuestions = [];
    let testIdx = 0;
    const testAnswers = new Map();
    let testStarted = false;
    let testSubmitted = false;

    // Review markers (persisted)
    const reviewMarked = new Set(); // question.id
    let practiceReviewMode = "ALL"; // ALL / REVIEW

    // Elements
    const tabPractice = document.getElementById("tabPractice");
    const tabTest = document.getElementById("tabTest");
    const practiceControls = document.getElementById("practiceControls");
    const testControls = document.getElementById("testControls");

    const moduleFilter = document.getElementById("moduleFilter");
    const modulePill = document.getElementById("modulePill");
    const qIndex = document.getElementById("qIndex");
    const questionText = document.getElementById("questionText");
    const chooseHint = document.getElementById("chooseHint");
    const optionsEl = document.getElementById("options");
    const feedbackEl = document.getElementById("feedback");
    const statsEl = document.getElementById("stats");
    const scoreEl = document.getElementById("score");

    const csvSelect = document.getElementById("csvSelect");
    const fileInput = document.getElementById("fileInput");
    const loadStatus = document.getElementById("loadStatus");
    const reviewCountPill = document.getElementById("reviewCountPill");
    const reviewFilter = document.getElementById("reviewFilter");
    const btnToggleReview = document.getElementById("btnToggleReview");
    const btnClearReview = document.getElementById("btnClearReview");

    const testResultsCard = document.getElementById("testResults");
    const resultsSummary = document.getElementById("resultsSummary");
    const reviewContainer = document.getElementById("reviewContainer");
    const btnShowAllReview = document.getElementById("btnShowAllReview");
    const btnHideReview = document.getElementById("btnHideReview");

    const testStatus = document.getElementById("testStatus");
    const testCountEl = document.getElementById("testCount");
    const btnStartTest = document.getElementById("btnStartTest");
    const btnEndTest = document.getElementById("btnEndTest");
    const btnSubmitTest = document.getElementById("btnSubmitTest");
    const btnResetTest = document.getElementById("btnResetTest");

    // Practice nav
    document.getElementById("btnPrev").onclick = () => {
      if (currentMode !== MODE.PRACTICE) return;
      if (practiceIdx > 0) { practiceIdx--; render(); }
    };
    document.getElementById("btnNext").onclick = () => {
      if (currentMode !== MODE.PRACTICE) return;
      if (practiceIdx < practiceFiltered.length - 1) { practiceIdx++; render(); }
    };
    document.getElementById("btnShuffle").onclick = () => {
      if (currentMode !== MODE.PRACTICE) return;
      shuffle(practiceFiltered);
      resetPracticeState(false);
      render();
    };
    document.getElementById("btnReset").onclick = () => {
      if (currentMode !== MODE.PRACTICE) return;
      resetPracticeState(false);
      render();
    };

    moduleFilter.onchange = () => {
      if (currentMode !== MODE.PRACTICE) return;
      applyPracticeFilter(moduleFilter.value);
    };

    reviewFilter.onchange = () => {
      if (currentMode !== MODE.PRACTICE) return;
      practiceReviewMode = reviewFilter.value;
      applyPracticeFilter(moduleFilter.value);
    };

    // Test buttons
    btnStartTest.onclick = () => startTest();
    btnEndTest.onclick = () => endTestEarly();
    btnSubmitTest.onclick = () => submitTest();
    btnResetTest.onclick = () => resetTest();

    // Review toggles (results card)
    btnShowAllReview.onclick = () => {
      reviewContainer.style.display = "block";
      btnShowAllReview.style.display = "none";
      btnHideReview.style.display = "inline-block";
    };
    btnHideReview.onclick = () => {
      reviewContainer.style.display = "none";
      btnShowAllReview.style.display = "inline-block";
      btnHideReview.style.display = "none";
    };

    // Tabs
    tabPractice.onclick = () => setMode(MODE.PRACTICE);
    tabTest.onclick = () => setMode(MODE.TEST);

    // Dropdown load
    csvSelect.addEventListener("change", async () => {
      await loadQuestionsFromFilename(csvSelect.value);
    });

    // Upload overrides dropdown
    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      await loadQuestionsFromFileObject(file);
    });

    // Mark for review toggle (persist after every change)
    btnToggleReview.onclick = () => {
      const list = (currentMode === MODE.PRACTICE) ? practiceFiltered : testQuestions;
      const i = (currentMode === MODE.PRACTICE) ? practiceIdx : testIdx;
      if (!list || list.length === 0) return;

      const q = list[i];
      if (!q || !q.id) return;

      if (reviewMarked.has(q.id)) reviewMarked.delete(q.id);
      else reviewMarked.add(q.id);

      saveReviewToStorage();          // ✅ persist
      updateReviewCount();

      // If we're in review-only filter, refresh list (may remove current item)
      if (currentMode === MODE.PRACTICE && practiceReviewMode === "REVIEW") {
        applyPracticeFilter(moduleFilter.value);
        return;
      }
      render();
    };

    btnClearReview.onclick = () => {
      const ok = confirm("Clear ALL marked questions for this question set?");
      if (!ok) return;
      reviewMarked.clear();
      clearReviewStorageForCurrentSet();
      saveReviewToStorage();
      updateReviewCount();
      if (currentMode === MODE.PRACTICE && practiceReviewMode === "REVIEW") {
        applyPracticeFilter(moduleFilter.value);
        return;
      }
      render();
    };

    async function loadQuestionsFromFilename(filename) {
      loadStatus.textContent = "Loading...";
      try {
        // NOTE: fetch needs http(s) (Live Server / python -m http.server). Upload works from file://
        const res = await fetch(`./${filename}`, { cache: "no-store" });
        if (!res.ok) throw new Error(`${filename} not found (${res.status})`);
        const csv = await res.text();
        const parsed = parseCSVToQuestions(csv);

        if (parsed.length === 0) {
          alert(`No valid questions found in ${filename}. Please check headers and data.`);
          loadStatus.textContent = "Load failed";
          return false;
        }

        QUESTIONS = parsed;
        loadStatus.textContent = `Loaded: ${filename}`;

        // ✅ set key + restore review list for this file
        currentSetKey = `file:${filename}`;
        loadReviewFromStorage(currentSetKey);
        saveReviewToStorage(); // keep LS_LAST_SET_KEY updated
        updateReviewCount();

        resetAndInitAll();
        return true;
      } catch (err) {
        console.error(err);
        loadStatus.textContent = "Load failed (fallback)";

        // Use builtin key and restore if present
        currentSetKey = "builtin";
        loadReviewFromStorage(currentSetKey);
        updateReviewCount();

        resetAndInitAll();
        return false;
      }
    }

    async function loadQuestionsFromFileObject(file) {
      loadStatus.textContent = "Loading...";
      try {
        const text = await file.text();
        const parsed = parseCSVToQuestions(text);

        if (parsed.length === 0) {
          alert("No valid questions found in the uploaded CSV. Please check headers and data.");
          loadStatus.textContent = "Load failed";
          return false;
        }

        QUESTIONS = parsed;
        loadStatus.textContent = `Loaded upload: ${file.name}`;

        // ✅ key based on file content hash so same upload restores marks
        const h = fastHash(text);
        currentSetKey = `upload:${file.name}:${h}`;
        loadReviewFromStorage(currentSetKey);
        saveReviewToStorage();
        updateReviewCount();

        resetAndInitAll();
        return true;
      } catch (err) {
        console.error(err);
        loadStatus.textContent = "Load failed";
        return false;
      }
    }

    function updateReviewCount() {
      reviewCountPill.textContent = `Review: ${reviewMarked.size}`;
      reviewCountPill.classList.toggle("warn", reviewMarked.size > 0);
    }

    // Auto-load last used set (if available), else dropdown default
    (async function boot() {
      updateReviewCount();

      const lastKey = localStorage.getItem(LS_LAST_SET_KEY);
      if (lastKey && lastKey.startsWith("file:")) {
        const fname = lastKey.slice("file:".length);
        // If it matches one of our dropdown options, select it
        const opt = Array.from(csvSelect.options).find(o => o.value === fname);
        if (opt) csvSelect.value = fname;
        await loadQuestionsFromFilename(csvSelect.value);
        return;
      }

      // Default: load dropdown selection
      await loadQuestionsFromFilename(csvSelect.value);
    })();

    function resetPracticeState(silent=true) {
      practiceIdx = 0;
      practiceScore = 0;
      practiceAnswers.clear();
      if (!silent) {
        statsEl.textContent = `0/${practiceFiltered.length || 0}`;
        scoreEl.textContent = `Score: 0`;
      }
    }

    function resetAndInitAll() {
      practiceIdx = 0;
      practiceScore = 0;
      practiceAnswers.clear();

      buildModuleDropdown();
      applyPracticeFilter("ALL");

      resetTest(true);
      setMode(currentMode);
      updateReviewCount();
    }

    function setMode(mode) {
      currentMode = mode;

      tabPractice.classList.toggle("active", mode === MODE.PRACTICE);
      tabTest.classList.toggle("active", mode === MODE.TEST);

      practiceControls.style.display = (mode === MODE.PRACTICE) ? "block" : "none";
      testControls.style.display = (mode === MODE.TEST) ? "block" : "none";

      if (mode === MODE.PRACTICE) testResultsCard.style.display = "none";
      else testResultsCard.style.display = testSubmitted ? "block" : "none";

      render();
    }

    function buildModuleDropdown() {
      moduleFilter.innerHTML = `<option value="ALL">All</option>`;
      const modules = Array.from(new Set(QUESTIONS.map(q => q.module))).filter(Boolean).sort();
      for (const m of modules) {
        const opt = document.createElement("option");
        opt.value = m;
        opt.textContent = m;
        moduleFilter.appendChild(opt);
      }
    }

    function applyPracticeFilter(moduleName) {
      let list = moduleName === "ALL" ? [...QUESTIONS] : QUESTIONS.filter(q => q.module === moduleName);

      if (practiceReviewMode === "REVIEW") {
        list = list.filter(q => q.id && reviewMarked.has(q.id));
      }

      practiceFiltered = list;
      resetPracticeState(false);
      render();
    }

    // -------------------------
    // Multi-select helpers
    // -------------------------
    function setEquals(a, b) {
      if (a.size !== b.size) return false;
      for (const v of a) if (!b.has(v)) return false;
      return true;
    }

    function setToLetters(set) {
      if (!set || set.size === 0) return "—";
      return Array.from(set).sort((x,y)=>x-y).map(i => String.fromCharCode(65+i)).join("");
    }

    // -------------------------
    // PRACTICE
    // -------------------------
    function handlePracticeSelection(q, chosenSet) {
      const prevSet = practiceAnswers.get(practiceIdx) || new Set();
      const prevCorrect = setEquals(prevSet, q.correctSet);
      const nowCorrect = setEquals(chosenSet, q.correctSet);

      if (!prevCorrect && nowCorrect) practiceScore++;
      if (prevCorrect && !nowCorrect) practiceScore--;

      practiceAnswers.set(practiceIdx, chosenSet);

      showPracticeFeedback(q, chosenSet);

      statsEl.textContent = `${practiceAnswers.size}/${practiceFiltered.length}`;
      scoreEl.textContent = `Score: ${practiceScore}`;
    }

    function showPracticeFeedback(q, chosenSet) {
      const ok = setEquals(chosenSet, q.correctSet);
      const correctLetters = setToLetters(q.correctSet);
      feedbackEl.innerHTML = `
        <div class="${ok ? "good" : "bad"}" style="font-weight: 700;">
          ${ok ? "Correct ✅" : `Incorrect ❌ (Correct: ${correctLetters})`}
        </div>
        <div class="muted" style="margin-top: 6px;">
          ${escapeHTML(q.explanation || "")}
        </div>
      `;
    }

    // -------------------------
    // TEST
    // -------------------------
    function startTest() {
      const total = QUESTIONS.length;
      if (total < 10) {
        alert("Please load more questions first (need at least 10).");
        return;
      }

      let n = parseInt(testCountEl.value || "60", 10);
      if (isNaN(n)) n = 60;
      n = Math.max(10, Math.min(n, 200));
      n = Math.min(n, total);
      testCountEl.value = String(n);

      testQuestions = [...QUESTIONS];
      shuffle(testQuestions);
      testQuestions = testQuestions.slice(0, n);

      testIdx = 0;
      testAnswers.clear();
      testStarted = true;
      testSubmitted = false;

      testStatus.textContent = `In progress • ${n} questions`;
      btnStartTest.disabled = true;
      btnEndTest.disabled = false;
      btnSubmitTest.disabled = false;
      btnResetTest.disabled = false;
      testCountEl.disabled = true;

      testResultsCard.style.display = "none";
      reviewContainer.style.display = "none";
      btnShowAllReview.style.display = "inline-block";
      btnHideReview.style.display = "none";
      reviewContainer.innerHTML = "";

      render();
    }

    function endTestEarly() {
      if (!testStarted || testSubmitted) return;
      const ok = confirm("End the test now? You can still submit to see your score.");
      if (!ok) return;
      testStatus.textContent = "Ended early • ready to submit";
      btnEndTest.disabled = true;
      render();
    }

    function submitTest() {
      if (!testStarted || testSubmitted) return;

      let correct = 0;
      for (let i = 0; i < testQuestions.length; i++) {
        const chosen = testAnswers.get(i) || new Set();
        if (setEquals(chosen, testQuestions[i].correctSet)) correct++;
      }

      const total = testQuestions.length;
      const answered = testAnswers.size;
      const pct = Math.round((correct / total) * 100);

      testSubmitted = true;
      testStatus.textContent = `Submitted • ${correct}/${total} (${pct}%)`;
      btnSubmitTest.disabled = true;
      btnEndTest.disabled = true;

      testResultsCard.style.display = "block";
      resultsSummary.textContent = `Score: ${correct}/${total} (${pct}%). Answered: ${answered}/${total}.`;

      buildReview();
      render();
    }

    function resetTest(silent=false) {
      testQuestions = [];
      testIdx = 0;
      testAnswers.clear();
      testStarted = false;
      testSubmitted = false;

      testStatus.textContent = "Not started";
      btnStartTest.disabled = false;
      btnEndTest.disabled = true;
      btnSubmitTest.disabled = true;
      btnResetTest.disabled = true;
      testCountEl.disabled = false;

      testResultsCard.style.display = "none";
      reviewContainer.style.display = "none";
      btnShowAllReview.style.display = "inline-block";
      btnHideReview.style.display = "none";
      reviewContainer.innerHTML = "";

      if (!silent) render();
    }

    function handleTestSelection(q, chosenSet) {
      if (!testStarted || testSubmitted) return;
      testAnswers.set(testIdx, chosenSet);

      feedbackEl.innerHTML = "";
      statsEl.textContent = `${testAnswers.size}/${testQuestions.length}`;
      scoreEl.textContent = `Score: —`;

      renderOptionsSelectionOnly(chosenSet);
    }

    function buildReview() {
      const frags = [];
      for (let i = 0; i < testQuestions.length; i++) {
        const q = testQuestions[i];
        const chosen = testAnswers.get(i) || new Set();
        const isCorrect = setEquals(chosen, q.correctSet);

        const chosenLetters = setToLetters(chosen);
        const correctLetters = setToLetters(q.correctSet);

        frags.push(`
          <div class="review-item">
            <div class="qtitle">${escapeHTML(q.text)}</div>
            <div class="meta">${escapeHTML(q.module || "—")} ${q.id ? "• " + escapeHTML(q.id) : ""} • Q${i+1}</div>
            <div class="ans">
              <span class="${isCorrect ? "good" : "bad"}"><strong>Your answer:</strong> ${chosenLetters}</span>
              <span class="good"><strong>Correct:</strong> ${correctLetters}</span>
            </div>
            <div class="muted" style="margin-top: 6px;">
              <strong>Options:</strong><br/>
              A. ${escapeHTML(q.options[0] || "")}<br/>
              B. ${escapeHTML(q.options[1] || "")}<br/>
              C. ${escapeHTML(q.options[2] || "")}<br/>
              D. ${escapeHTML(q.options[3] || "")}
              ${q.options[4] ? `<br/>E. ${escapeHTML(q.options[4] || "")}` : ""}
              ${q.options[5] ? `<br/>F. ${escapeHTML(q.options[5] || "")}` : ""}
            </div>
            ${q.explanation ? `<div class="muted" style="margin-top: 8px;"><strong>Explanation:</strong> ${escapeHTML(q.explanation)}</div>` : ""}
          </div>
        `);
      }
      reviewContainer.innerHTML = frags.join("");
    }

    // -------------------------
    // RENDER + NAV
    // -------------------------
    const questionCard = document.getElementById("questionCard");
    const testNav = document.createElement("div");
    testNav.className = "row";
    testNav.style.marginTop = "10px";
    testNav.innerHTML = `
      <button id="btnTestPrev">Prev</button>
      <button class="primary" id="btnTestNext">Next</button>
    `;
    questionCard.appendChild(testNav);

    const btnTestPrev = testNav.querySelector("#btnTestPrev");
    const btnTestNext = testNav.querySelector("#btnTestNext");

    btnTestPrev.onclick = () => {
      if (currentMode === MODE.PRACTICE) {
        if (practiceIdx > 0) { practiceIdx--; render(); }
        return;
      }
      if (!testStarted) return;
      if (testIdx > 0) { testIdx--; render(); }
    };

    btnTestNext.onclick = () => {
      if (currentMode === MODE.PRACTICE) {
        if (practiceIdx < practiceFiltered.length - 1) { practiceIdx++; render(); }
        return;
      }
      if (!testStarted) return;
      if (testIdx < testQuestions.length - 1) { testIdx++; render(); }
    };

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") {
        if (currentMode === MODE.PRACTICE) { if (practiceIdx > 0) { practiceIdx--; render(); } }
        else if (testStarted) { if (testIdx > 0) { testIdx--; render(); } }
      }
      if (e.key === "ArrowRight") {
        if (currentMode === MODE.PRACTICE) { if (practiceIdx < practiceFiltered.length - 1) { practiceIdx++; render(); } }
        else if (testStarted) { if (testIdx < testQuestions.length - 1) { testIdx++; render(); } }
      }
    });

    function render() {
      const list = (currentMode === MODE.PRACTICE) ? practiceFiltered : testQuestions;
      const i = (currentMode === MODE.PRACTICE) ? practiceIdx : testIdx;

      if (currentMode === MODE.PRACTICE && (!practiceFiltered || practiceFiltered.length === 0)) {
        questionText.textContent = (practiceReviewMode === "REVIEW")
          ? "No marked questions. Mark some questions for review first."
          : "No questions available. Load a CSV or choose another module.";
        chooseHint.textContent = "";
        optionsEl.innerHTML = "";
        feedbackEl.innerHTML = "";
        modulePill.textContent = "—";
        qIndex.textContent = "";
        statsEl.textContent = "0/0";
        scoreEl.textContent = "Score: 0";
        btnToggleReview.textContent = "☆ Mark for review";
        btnToggleReview.classList.remove("warn");
        return;
      }

      if (currentMode === MODE.TEST && !testStarted) {
        questionText.textContent = "Start a Mock Exam to practice 60 random questions.";
        chooseHint.textContent = "";
        optionsEl.innerHTML = "";
        feedbackEl.innerHTML = `<div class="muted">Go to <strong>Test (Mock Exam)</strong> tab and click <strong>Start Test</strong>.</div>`;
        modulePill.textContent = "Test mode";
        qIndex.textContent = "";
        statsEl.textContent = "0/0";
        scoreEl.textContent = "Score: —";
        btnToggleReview.textContent = "☆ Mark for review";
        btnToggleReview.classList.remove("warn");
        return;
      }

      const q = list[i];
      modulePill.textContent = q.module || "—";
      qIndex.textContent = `Q ${i + 1} of ${list.length}` + (q.id ? `  •  ${q.id}` : "");
      questionText.textContent = q.text;

      const isMarked = q?.id && reviewMarked.has(q.id);
      btnToggleReview.textContent = isMarked ? "★ Marked (click to unmark)" : "☆ Mark for review";
      btnToggleReview.classList.toggle("warn", !!isMarked);

      const isMulti = q.correctSet.size > 1;
      chooseHint.textContent = isMulti ? "Choose all that apply." : "";

      if (currentMode === MODE.PRACTICE) {
        statsEl.textContent = `${practiceAnswers.size}/${practiceFiltered.length}`;
        scoreEl.textContent = `Score: ${practiceScore}`;
      } else {
        statsEl.textContent = `${testAnswers.size}/${testQuestions.length}`;
        scoreEl.textContent = testSubmitted ? "Score: (see results)" : "Score: —";
      }

      const chosenSet =
        (currentMode === MODE.PRACTICE)
          ? (practiceAnswers.get(practiceIdx) || new Set())
          : (testAnswers.get(testIdx) || new Set());

      optionsEl.innerHTML = "";
      feedbackEl.innerHTML = "";

      const inputType = isMulti ? "checkbox" : "radio";
      const groupName = "opt";

      q.options.forEach((optText, optIdx) => {
        const label = document.createElement("label");
        label.className = "opt";

        const input = document.createElement("input");
        input.type = inputType;
        input.name = groupName;
        input.checked = chosenSet.has(optIdx);
        input.disabled = (currentMode === MODE.TEST && testSubmitted);

        input.onchange = () => {
          const base =
            (currentMode === MODE.PRACTICE)
              ? (practiceAnswers.get(practiceIdx) || new Set())
              : (testAnswers.get(testIdx) || new Set());

          const next = new Set(base);

          if (isMulti) {
            if (input.checked) next.add(optIdx);
            else next.delete(optIdx);
          } else {
            next.clear();
            next.add(optIdx);
          }

          if (currentMode === MODE.PRACTICE) handlePracticeSelection(q, next);
          else handleTestSelection(q, next);
        };

        label.appendChild(input);
        label.appendChild(document.createTextNode(`${String.fromCharCode(65 + optIdx)}. ${optText}`));
        optionsEl.appendChild(label);
      });

      if (currentMode === MODE.PRACTICE) {
        if (practiceAnswers.has(practiceIdx)) showPracticeFeedback(q, chosenSet);
      } else {
        if (testSubmitted) {
          const ok = setEquals(chosenSet, q.correctSet);
          const correctLetters = setToLetters(q.correctSet);
          feedbackEl.innerHTML = `
            <div class="${ok ? "good" : "bad"}" style="font-weight: 700;">
              ${ok ? "Correct ✅" : `Incorrect ❌ (Correct: ${correctLetters})`}
            </div>
            ${q.explanation ? `<div class="muted" style="margin-top: 6px;">${escapeHTML(q.explanation)}</div>` : ""}
          `;
        }
      }
    }

    function renderOptionsSelectionOnly(chosenSet) {
      const inputs = optionsEl.querySelectorAll('input');
      inputs.forEach((inp, idx) => {
        inp.checked = chosenSet.has(idx);
      });
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // -------------------------
    // CSV Parsing (A-F supported)
    // -------------------------
    function parseCSVToQuestions(csvText) {
      const lines = csvText.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n").filter(l => l.trim().length > 0);
      if (lines.length < 2) return [];

      const headers = splitCSVLine(lines[0]).map(h => h.trim().toLowerCase());
      const idxOf = (name) => headers.indexOf(name.toLowerCase());

      const required = ["module", "question", "a", "b", "c", "d", "answer"];
      for (const r of required) {
        if (idxOf(r) === -1) return [];
      }

      const idI = idxOf("id");
      const moduleI = idxOf("module");
      const qI = idxOf("question");
      const aI = idxOf("a");
      const bI = idxOf("b");
      const cI = idxOf("c");
      const dI = idxOf("d");
      const ansI = idxOf("answer");
      const expI = idxOf("explanation");

      const out = [];

      for (let r = 1; r < lines.length; r++) {
        const cols = splitCSVLine(lines[r]);

        const module = (cols[moduleI] || "").trim();
        const text = (cols[qI] || "").trim();
        const A = (cols[aI] || "").trim();
        const B = (cols[bI] || "").trim();
        const C = (cols[cI] || "").trim();
        const D = (cols[dI] || "").trim();
        const E = idxOf("e") >= 0 ? (cols[idxOf("e")] || "").trim() : "";
        const F = idxOf("f") >= 0 ? (cols[idxOf("f")] || "").trim() : "";

        const answerRaw = (cols[ansI] || "").trim().toUpperCase().replace(/[^A-F]/g, "");
        const explanation = expI >= 0 ? (cols[expI] || "").trim() : "";
        const id = idI >= 0 ? (cols[idI] || "").trim() : "";

        if (!module || !text || !A || !B || !C || !D) continue;
        if (!answerRaw) continue;

        const correctSet = new Set();
        for (const ch of answerRaw) {
          const idx = "ABCDEF".indexOf(ch);
          if (idx >= 0) correctSet.add(idx);
        }
        if (correctSet.size === 0) continue;

        out.push({
          id,
          module,
          text,
          options: [A, B, C, D, E, F].filter(o => o !== ""),
          correctSet,
          explanation
        });
      }

      return out;
    }

    function splitCSVLine(line) {
      const result = [];
      let current = "";
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const ch = line[i];

        if (ch === '"') {
          const next = line[i + 1];
          if (inQuotes && next === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === "," && !inQuotes) {
          result.push(current);
          current = "";
        } else {
          current += ch;
        }
      }
      result.push(current);
      return result;
    }

    function escapeHTML(str) {
      return String(str || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
  </script>
</body>
</html>
